using System;  namespace BigIntNumbersCalculator {     public class BigInt : String     {         private const int maxLength = 70;          private uint[] data = null;         public int dataLength;         public BigInt()         {             data = new uint[maxLength];             dataLength = 1;         }          public BigInt(BigInt bi)         {             data = new uint[maxLength];              dataLength = bi.dataLength;              for (int i = 0; i < dataLength; i++)                 data[i] = bi.data[i];         }          public BigInt(string value, int radix = 10)         {             BigInt multiplier = new BigInt(1);             BigInt result = new BigInt();             value = (value.ToUpper()).Trim();             int limit = 0;              if (value[0] == '-')                 limit = 1;              for (int i = value.Length - 1; i >= limit; i--)             {                 int posVal = (int)value[i];                  if (posVal >= '0' && posVal <= '9')                     posVal -= '0';                 else if (posVal >= 'A' && posVal <= 'Z')                     posVal = (posVal - 'A') + 10;                 else                     posVal = 9999999;                   if (posVal >= radix)                     throw (new ArithmeticException("Invalid string in constructor."));                 else                 {                     if (value[0] == '-')                         posVal = -posVal;                      result = result + (multiplier * posVal);                      if ((i - 1) >= limit)                         multiplier = multiplier * radix;                 }             }              if (value[0] == '-')             {                 if ((result.data[maxLength - 1] & 0x80000000) == 0)                     throw (new ArithmeticException("Negative underflow in constructor."));             }             else             {                 if ((result.data[maxLength - 1] & 0x80000000) != 0)                     throw (new ArithmeticException("Positive overflow in constructor."));             }              data = new uint[maxLength];             for (int i = 0; i < result.dataLength; i++)                 data[i] = result.data[i];              dataLength = result.dataLength;         }         public BigInt(long value)         {             data = new uint[maxLength];             long tempVal = value;             dataLength = 0;             while (value != 0 && dataLength < maxLength)             {                 data[dataLength] = (uint)(value & 0xFFFFFFFF);                 value >>= 32;                 dataLength++;             }             if (tempVal > 0)             {                 if (value != 0 || (data[maxLength - 1] & 0x80000000) != 0)                     throw (new ArithmeticException("Positive overflow in constructor."));             }             else if (tempVal < 0)             {                 if (value != -1 || (data[dataLength - 1] & 0x80000000) == 0)                     throw (new ArithmeticException("Negative underflow in constructor."));             }              if (dataLength == 0)                 dataLength = 1;         }                  public BigInt(ulong value)         {             data = new uint[maxLength];             dataLength = 0;             while (value != 0 && dataLength < maxLength)             {                 data[dataLength] = (uint)(value & 0xFFFFFFFF);                 value >>= 32;                 dataLength++;             }              if (value != 0 || (data[maxLength - 1] & 0x80000000) != 0)                 throw (new ArithmeticException("Positive overflow in constructor."));              if (dataLength == 0)                 dataLength = 1;         }         public BigInt(uint[] inData)         {             dataLength = inData.Length;              if (dataLength > maxLength)                 throw (new ArithmeticException("Byte overflow in constructor."));              data = new uint[maxLength];              for (int i = dataLength - 1, j = 0; i >= 0; i--, j++)                 data[j] = inData[i];              while (dataLength > 1 && data[dataLength - 1] == 0)                 dataLength--;         }          public static implicit operator BigInt(long value)         {             return (new BigInt(value));         }         public static implicit operator BigInt(ulong value)         {             return (new BigInt(value));         }         public static implicit operator BigInt(int value)         {             return (new BigInt((long)value));         }          public static implicit operator BigInt(uint value)         {             return (new BigInt((ulong)value));         }         public static BigInt operator +(BigInt bi1, BigInt bi2)         {             BigInt result = new BigInt();              result.dataLength = (bi1.dataLength > bi2.dataLength) ? bi1.dataLength : bi2.dataLength;              long carry = 0;             for (int i = 0; i < result.dataLength; i++)             {                 long sum = (long)bi1.data[i] + (long)bi2.data[i] + carry;                 carry = sum >> 32;                 result.data[i] = (uint)(sum & 0xFFFFFFFF);             }              if (carry != 0 && result.dataLength < maxLength)             {                 result.data[result.dataLength] = (uint)(carry);                 result.dataLength++;             }              while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;              int lastPos = maxLength - 1;             if ((bi1.data[lastPos] & 0x80000000) == (bi2.data[lastPos] & 0x80000000) &&                (result.data[lastPos] & 0x80000000) != (bi1.data[lastPos] & 0x80000000))             {                 throw (new ArithmeticException());             }              return result;         }         public static BigInt operator ++(BigInt bi1)         {             BigInt result = new BigInt(bi1);              long val, carry = 1;             int index = 0;              while (carry != 0 && index < maxLength)             {                 val = (long)(result.data[index]);                 val++;                  result.data[index] = (uint)(val & 0xFFFFFFFF);                 carry = val >> 32;                  index++;             }              if (index > result.dataLength)                 result.dataLength = index;             else             {                 while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                     result.dataLength--;             }             int lastPos = maxLength - 1;              if ((bi1.data[lastPos] & 0x80000000) == 0 &&                (result.data[lastPos] & 0x80000000) != (bi1.data[lastPos] & 0x80000000))             {                 throw (new ArithmeticException("Overflow in ++."));             }             return result;         }          public static BigInt operator -(BigInt bi1, BigInt bi2)         {             BigInt result = new BigInt();              result.dataLength = (bi1.dataLength > bi2.dataLength) ? bi1.dataLength : bi2.dataLength;              long carryIn = 0;             for (int i = 0; i < result.dataLength; i++)             {                 long diff;                  diff = (long)bi1.data[i] - (long)bi2.data[i] - carryIn;                 result.data[i] = (uint)(diff & 0xFFFFFFFF);                  if (diff < 0)                     carryIn = 1;                 else                     carryIn = 0;             }              if (carryIn != 0)             {                 for (int i = result.dataLength; i < maxLength; i++)                     result.data[i] = 0xFFFFFFFF;                 result.dataLength = maxLength;             }             while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;              int lastPos = maxLength - 1;             if ((bi1.data[lastPos] & 0x80000000) != (bi2.data[lastPos] & 0x80000000) &&                (result.data[lastPos] & 0x80000000) != (bi1.data[lastPos] & 0x80000000))             {                 throw (new ArithmeticException());             }              return result;         }          public static BigInt operator --(BigInt bi1)         {             BigInt result = new BigInt(bi1);              long val;             bool carryIn = true;             int index = 0;              while (carryIn && index < maxLength)             {                 val = (long)(result.data[index]);                 val--;                  result.data[index] = (uint)(val & 0xFFFFFFFF);                  if (val >= 0)                     carryIn = false;                  index++;             }              if (index > result.dataLength)                 result.dataLength = index;              while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;             int lastPos = maxLength - 1;              if ((bi1.data[lastPos] & 0x80000000) != 0 &&                (result.data[lastPos] & 0x80000000) != (bi1.data[lastPos] & 0x80000000))             {                 throw (new ArithmeticException("Underflow in --."));             }              return result;         }          public static BigInt operator *(BigInt bi1, BigInt bi2)         {             int lastPos = maxLength - 1;             bool bi1Neg = false, bi2Neg = false;             try             {                 if ((bi1.data[lastPos] & 0x80000000) != 0)                 {                     bi1Neg = true; bi1 = -bi1;                 }                 if ((bi2.data[lastPos] & 0x80000000) != 0)                 {                     bi2Neg = true; bi2 = -bi2;                 }             }             catch (Exception) { }              BigInt result = new BigInt();             try             {                 for (int i = 0; i < bi1.dataLength; i++)                 {                     if (bi1.data[i] == 0) continue;                      ulong mcarry = 0;                     for (int j = 0, k = i; j < bi2.dataLength; j++, k++)                     {                         // k = i + j                         ulong val = ((ulong)bi1.data[i] * (ulong)bi2.data[j]) +                                      (ulong)result.data[k] + mcarry;                          result.data[k] = (uint)(val & 0xFFFFFFFF);                         mcarry = (val >> 32);                     }                      if (mcarry != 0)                         result.data[i + bi2.dataLength] = (uint)mcarry;                 }             }             catch (Exception)             {                 throw (new ArithmeticException("Multiplication overflow."));             }               result.dataLength = bi1.dataLength + bi2.dataLength;             if (result.dataLength > maxLength)                 result.dataLength = maxLength;              while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;             if ((result.data[lastPos] & 0x80000000) != 0)             {                 if (bi1Neg != bi2Neg && result.data[lastPos] == 0x80000000)                 {                     if (result.dataLength == 1)                         return result;                     else                     {                         bool isMaxNeg = true;                         for (int i = 0; i < result.dataLength - 1 && isMaxNeg; i++)                         {                             if (result.data[i] != 0)                                 isMaxNeg = false;                         }                          if (isMaxNeg)                             return result;                     }                 }                  throw (new ArithmeticException("Multiplication overflow."));             }             if (bi1Neg != bi2Neg)                 return -result;              return result;         }          public static BigInt operator <<(BigInt bi1, int shiftVal)         {             BigInt result = new BigInt(bi1);             result.dataLength = shiftLeft(result.data, shiftVal);              return result;         }          private static int shiftLeft(uint[] buffer, int shiftVal)         {             int shiftAmount = 32;             int bufLen = buffer.Length;              while (bufLen > 1 && buffer[bufLen - 1] == 0)                 bufLen--;              for (int count = shiftVal; count > 0;)             {                 if (count < shiftAmount)                     shiftAmount = count;                 ulong carry = 0;                 for (int i = 0; i < bufLen; i++)                 {                     ulong val = ((ulong)buffer[i]) << shiftAmount;                     val |= carry;                      buffer[i] = (uint)(val & 0xFFFFFFFF);                     carry = val >> 32;                 }                  if (carry != 0)                 {                     if (bufLen + 1 <= buffer.Length)                     {                         buffer[bufLen] = (uint)carry;                         bufLen++;                     }                 }                 count -= shiftAmount;             }             return bufLen;         }          public static BigInt operator >>(BigInt bi1, int shiftVal)         {             BigInt result = new BigInt(bi1);             result.dataLength = shiftRight(result.data, shiftVal);               if ((bi1.data[maxLength - 1] & 0x80000000) != 0) // negative             {                 for (int i = maxLength - 1; i >= result.dataLength; i--)                     result.data[i] = 0xFFFFFFFF;                  uint mask = 0x80000000;                 for (int i = 0; i < 32; i++)                 {                     if ((result.data[result.dataLength - 1] & mask) != 0)                         break;                      result.data[result.dataLength - 1] |= mask;                     mask >>= 1;                 }                 result.dataLength = maxLength;             }              return result;         }           private static int shiftRight(uint[] buffer, int shiftVal)         {             int shiftAmount = 32;             int invShift = 0;             int bufLen = buffer.Length;              while (bufLen > 1 && buffer[bufLen - 1] == 0)                 bufLen--;              for (int count = shiftVal; count > 0;)             {                 if (count < shiftAmount)                 {                     shiftAmount = count;                     invShift = 32 - shiftAmount;                 }                  ulong carry = 0;                 for (int i = bufLen - 1; i >= 0; i--)                 {                     ulong val = ((ulong)buffer[i]) >> shiftAmount;                     val |= carry;                      carry = ((ulong)buffer[i]) << invShift;                     buffer[i] = (uint)(val);                 }                  count -= shiftAmount;             }              while (bufLen > 1 && buffer[bufLen - 1] == 0)                 bufLen--;              return bufLen;         }          public static BigInt operator ~(BigInt bi1)         {             BigInt result = new BigInt(bi1);              for (int i = 0; i < maxLength; i++)                 result.data[i] = (uint)(~(bi1.data[i]));              result.dataLength = maxLength;              while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;              return result;         }          public static BigInt operator -(BigInt bi1)         {             if (bi1.dataLength == 1 && bi1.data[0] == 0)                 return (new BigInt());              BigInt result = new BigInt(bi1);              for (int i = 0; i < maxLength; i++)                 result.data[i] = (uint)(~(bi1.data[i]));              long val, carry = 1;             int index = 0;              while (carry != 0 && index < maxLength)             {                 val = (long)(result.data[index]);                 val++;                  result.data[index] = (uint)(val & 0xFFFFFFFF);                 carry = val >> 32;                  index++;             }              if ((bi1.data[maxLength - 1] & 0x80000000) == (result.data[maxLength - 1] & 0x80000000))                 throw (new ArithmeticException("Overflow in negation.\n"));              result.dataLength = maxLength;              while (result.dataLength > 1 && result.data[result.dataLength - 1] == 0)                 result.dataLength--;             return result;         }          public static bool operator ==(BigInt bi1, BigInt bi2)         {             return bi1.Equals(bi2);         }           public static bool operator !=(BigInt bi1, BigInt bi2)         {             return !(bi1.Equals(bi2));         }           public override bool Equals(object o)         {             BigInt bi = (BigInt)o;              if (this.dataLength != bi.dataLength)                 return false;              for (int i = 0; i < this.dataLength; i++)             {                 if (this.data[i] != bi.data[i])                     return false;             }             return true;         }           public override int GetHashCode()         {             return this.ToString().GetHashCode();         }          public static bool operator >(BigInt bi1, BigInt bi2)         {             int pos = maxLength - 1;              if ((bi1.data[pos] & 0x80000000) != 0 && (bi2.data[pos] & 0x80000000) == 0)                 return false;              else if ((bi1.data[pos] & 0x80000000) == 0 && (bi2.data[pos] & 0x80000000) != 0)                 return true;              int len = (bi1.dataLength > bi2.dataLength) ? bi1.dataLength : bi2.dataLength;             for (pos = len - 1; pos >= 0 && bi1.data[pos] == bi2.data[pos]; pos--) ;              if (pos >= 0)             {                 if (bi1.data[pos] > bi2.data[pos])                     return true;                 return false;             }             return false;         }           public static bool operator <(BigInt bi1, BigInt bi2)         {             int pos = maxLength - 1;              if ((bi1.data[pos] & 0x80000000) != 0 && (bi2.data[pos] & 0x80000000) == 0)                 return true;              else if ((bi1.data[pos] & 0x80000000) == 0 && (bi2.data[pos] & 0x80000000) != 0)                 return false;              int len = (bi1.dataLength > bi2.dataLength) ? bi1.dataLength : bi2.dataLength;             for (pos = len - 1; pos >= 0 && bi1.data[pos] == bi2.data[pos]; pos--) ;              if (pos >= 0)             {                 if (bi1.data[pos] < bi2.data[pos])                     return true;                 return false;             }             return false;         }           public static bool operator >=(BigInt bi1, BigInt bi2)         {             return (bi1 == bi2 || bi1 > bi2);         }           public static bool operator <=(BigInt bi1, BigInt bi2)         {             return (bi1 == bi2 || bi1 < bi2);         }           //***********************************************************************         // Private function that supports the division of two numbers with         // a divisor that has more than 1 digit.         //         // Algorithm taken from [1]         //***********************************************************************          private static void multiByteDivide(BigInt bi1, BigInt bi2,                                             BigInt outQuotient, BigInt outRemainder)         {             uint[] result = new uint[maxLength];              int remainderLen = bi1.dataLength + 1;             uint[] remainder = new uint[remainderLen];              uint mask = 0x80000000;             uint val = bi2.data[bi2.dataLength - 1];             int shift = 0, resultPos = 0;              while (mask != 0 && (val & mask) == 0)             {                 shift++; mask >>= 1;             }              for (int i = 0; i < bi1.dataLength; i++)                 remainder[i] = bi1.data[i];             shiftLeft(remainder, shift);             bi2 = bi2 << shift;             int j = remainderLen - bi2.dataLength;             int pos = remainderLen - 1;              ulong firstDivisorByte = bi2.data[bi2.dataLength - 1];             ulong secondDivisorByte = bi2.data[bi2.dataLength - 2];              int divisorLen = bi2.dataLength + 1;             uint[] dividendPart = new uint[divisorLen];              while (j > 0)             {                 ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                 ulong q_hat = dividend / firstDivisorByte;                 ulong r_hat = dividend % firstDivisorByte;                  bool done = false;                 while (!done)                 {                     done = true;                      if (q_hat == 0x100000000 ||                        (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                     {                         q_hat--;                         r_hat += firstDivisorByte;                          if (r_hat < 0x100000000)                             done = false;                     }                 }                  for (int h = 0; h < divisorLen; h++)                     dividendPart[h] = remainder[pos - h];                  BigInt kk = new BigInt(dividendPart);                 BigInt ss = bi2 * (long)q_hat;                  while (ss > kk)                 {                     q_hat--;                     ss -= bi2;                     //Console.WriteLine(ss);                 }                 BigInt yy = kk - ss;                  for (int h = 0; h < divisorLen; h++)                     remainder[pos - h] = yy.data[bi2.dataLength - h];                  result[resultPos++] = (uint)q_hat;                  pos--;                 j--;             }              outQuotient.dataLength = resultPos;             int y = 0;             for (int x = outQuotient.dataLength - 1; x >= 0; x--, y++)                 outQuotient.data[y] = result[x];             for (; y < maxLength; y++)                 outQuotient.data[y] = 0;              while (outQuotient.dataLength > 1 && outQuotient.data[outQuotient.dataLength - 1] == 0)                 outQuotient.dataLength--;              if (outQuotient.dataLength == 0)                 outQuotient.dataLength = 1;              outRemainder.dataLength = shiftRight(remainder, shift);              for (y = 0; y < outRemainder.dataLength; y++)                 outRemainder.data[y] = remainder[y];             for (; y < maxLength; y++)                 outRemainder.data[y] = 0;         }          private static void singleByteDivide(BigInt bi1, BigInt bi2,                                              BigInt outQuotient, BigInt outRemainder)         {             uint[] result = new uint[maxLength];             int resultPos = 0;              for (int i = 0; i < maxLength; i++)                 outRemainder.data[i] = bi1.data[i];             outRemainder.dataLength = bi1.dataLength;              while (outRemainder.dataLength > 1 && outRemainder.data[outRemainder.dataLength - 1] == 0)                 outRemainder.dataLength--;              ulong divisor = (ulong)bi2.data[0];             int pos = outRemainder.dataLength - 1;             ulong dividend = (ulong)outRemainder.data[pos];              if (dividend >= divisor)             {                 ulong quotient = dividend / divisor;                 result[resultPos++] = (uint)quotient;                  outRemainder.data[pos] = (uint)(dividend % divisor);             }             pos--;              while (pos >= 0)             {                 dividend = ((ulong)outRemainder.data[pos + 1] << 32) + (ulong)outRemainder.data[pos];                 ulong quotient = dividend / divisor;                 result[resultPos++] = (uint)quotient;                  outRemainder.data[pos + 1] = 0;                 outRemainder.data[pos--] = (uint)(dividend % divisor);             }              outQuotient.dataLength = resultPos;             int j = 0;             for (int i = outQuotient.dataLength - 1; i >= 0; i--, j++)                 outQuotient.data[j] = result[i];             for (; j < maxLength; j++)                 outQuotient.data[j] = 0;              while (outQuotient.dataLength > 1 && outQuotient.data[outQuotient.dataLength - 1] == 0)                 outQuotient.dataLength--;              if (outQuotient.dataLength == 0)                 outQuotient.dataLength = 1;              while (outRemainder.dataLength > 1 && outRemainder.data[outRemainder.dataLength - 1] == 0)                 outRemainder.dataLength--;         }           public static BigInt operator /(BigInt bi1, BigInt bi2)         {             BigInt quotient = new BigInt();             BigInt remainder = new BigInt();              int lastPos = maxLength - 1;             bool divisorNeg = false, dividendNeg = false;              if ((bi1.data[lastPos] & 0x80000000) != 0)     // bi1 negative             {                 bi1 = -bi1;                 dividendNeg = true;             }             if ((bi2.data[lastPos] & 0x80000000) != 0)     // bi2 negative             {                 bi2 = -bi2;                 divisorNeg = true;             }              if (bi1 < bi2)             {                 return quotient;             }              else             {                 if (bi2.dataLength == 1)                     singleByteDivide(bi1, bi2, quotient, remainder);                 else                     multiByteDivide(bi1, bi2, quotient, remainder);                  if (dividendNeg != divisorNeg)                     return -quotient;                  return quotient;             }         }          public static BigInt operator %(BigInt bi1, BigInt bi2)         {             BigInt quotient = new BigInt();             BigInt remainder = new BigInt(bi1);              int lastPos = maxLength - 1;             bool dividendNeg = false;              if ((bi1.data[lastPos] & 0x80000000) != 0)     // bi1 negative             {                 bi1 = -bi1;                 dividendNeg = true;             }             if ((bi2.data[lastPos] & 0x80000000) != 0)     // bi2 negative                 bi2 = -bi2;              if (bi1 < bi2)             {                 return remainder;             }              else             {                 if (bi2.dataLength == 1)                     singleByteDivide(bi1, bi2, quotient, remainder);                 else                     multiByteDivide(bi1, bi2, quotient, remainder);                  if (dividendNeg)                     return -remainder;                  return remainder;             }         }            public BigInt max(BigInt bi)         {             if (this > bi)                 return (new BigInt(this));             else                 return (new BigInt(bi));         }           //***********************************************************************         // Returns min(this, bi)         //***********************************************************************          public BigInt min(BigInt bi)         {             if (this < bi)                 return (new BigInt(this));             else                 return (new BigInt(bi));          }           public BigInt abs()         {             if ((this.data[maxLength - 1] & 0x80000000) != 0)                 return (-this);             else                 return (new BigInt(this));         }          public override string ToString()         {             return ToString(10);         }         public string ToString(int radix)         {             if (radix < 2 || radix > 36)                 throw (new ArgumentException("Radix must be >= 2 and <= 36"));              string charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";             string result = "";              BigInt a = this;              bool negative = false;             if ((a.data[maxLength - 1] & 0x80000000) != 0)             {                 negative = true;                 try                 {                     a = -a;                 }                 catch (Exception) { }             }              BigInt quotient = new BigInt();             BigInt remainder = new BigInt();             BigInt biRadix = new BigInt(radix);              if (a.dataLength == 1 && a.data[0] == 0)                 result = "0";             else             {                 while (a.dataLength > 1 || (a.dataLength == 1 && a.data[0] != 0))                 {                     singleByteDivide(a, biRadix, quotient, remainder);                      if (remainder.data[0] < 10)                         result = remainder.data[0] + result;                     else                         result = charSet[(int)remainder.data[0] - 10] + result;                      a = quotient;                 }                 if (negative)                     result = "-" + result;             }              return result;         }           public string ToHexString()         {             string result = data[dataLength - 1].ToString("X");              for (int i = dataLength - 2; i >= 0; i--)             {                 result += data[i].ToString("X8");             }              return result;         }     } } 